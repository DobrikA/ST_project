Описание проекта
Проект собран в Keil 5 (GCC V5.06)

Структура:
/Common_lib
Файлы с расчётом CRC8.

/STM32F4xx_StdPeriph_Driver
Библиотеки для управления периферией STM32F4xx

/Trird_party_lib
Исходники FreeRTOS8.0.1

/UART+ADC
Исходники самого проекта

Кратко по принципу работы.

main.c
Инициализация периферии, запуск планировщика.

uart.c
- Инициализация USART1 RX DMA + IDLE interrupt
- Реализация printf()/UART_printf. Отправка данных
на хост через DMA. Работает с перебоями, нужно дорабатывать раздельный
доступ к ресурсу (USART1->DR). Но отправка работает (для тестов).

- irq_routine.c Обработчики прерываний:
UART_DMA_TX_IRQ_HANDLER() Прерывание по окончанию передачи USART1 
TX DMA. Возвращает семафор xSemaphore_UART_TX_END (блокирует задачу 
DecodeInputDataTask() до завершения отправки пакета хосту)
ADC_DMA_IRQ_HANDLER() Обработчик прерывания DMA по окончанию
записи 32-х отсчётов АЦП1 в массив 
Отдает семафор xSemaphore_ADC_DATA_READY, который блокирует задачу 
AdcAvgCalcTask(), выполняющую усреднение отсчётов АЦП.
Результат усреднения записывается в переменную adc_result, принадлежит
структуре dev_cntrl_tbl, содержащей описание устройства (его состояние
и значение переменных во время выполнения кода).
TIM3_IRQHandler() Обработчик прерывания для обновления состояния порта.
В устройстве задан portA (в составе структуры dev_cntrl_tbl).
Возвращает семафор xSemaphore_PORT_RELOAD, по которому в задаче
PortReloadTask() происходит обновление состояния portA. Частота
обновления задается функцией SetAdcFrequency().
USART1_IRQHandler() Обработчик для USART1 IDLE interrupt. 
Передает через очередь xQueueStringDataIn указатель на данные
и размер (для анализа в задаче DecodeInputDataTask()) в структуре
uart_in_buf типа cyrcle_buffer (заполняется DMA).

dev_rtos_routine.c
Описание задач и создание очередей/семафоров/мьютексов
для обмена данными между задачами/прерываниями.

adc_timer.c
Инициализация TIM2 в режиме update (up counting) в качестве
запускающего события для АЦП1. Таймер переполняется с частотой 100 Гц,
отсюда получаем чстоту измерения АЦП1 в 100 Гц (данные с АЦП1
перегружаются через DMA в массив AdcDataBuffer размером ADC_AVG_SIZE)
для последующего усреднения в задаче AdcAvgCalcTask().

adc_routine.c
AdcAverageCalculation() функция расчёта среднего
ADCInit() - инициализация АЦП1 (источником сигнала является напряжение с 
встроенного термодатчика, запускающее событие - переполнения TIM2),
инициализация DMA.

gpio_timer.c
SetAdcFrequency() - функция изменения частоты переполнения TIM.
При переполнении возникает прерывание, возвращается семафор, в задаче
происходит обновления выводов порта.
GpioCntrlTimerInit() - собственно инициализация TIM3 для периодической
прогрузки порта.

dev_data_routine.c
DeviceInit() - установка начального состояния переменных устройства
DecodeInputData() - разбор принятого пакета, проверка CRC8, модификация
пакета (type & 0x80), расчёт нового CRC8, отправка ответа на хост.

P.S. сейчас задана преамбула 'A' (переменная pack_preamble)
+ максимальное значение счётчика (cnt) установлено в 'B'. Для
простоты отладки.
Код рабочий, проверял на железе с HyperTerminal, на 460800, 8 бит, без
flow control, 1 стоповый бит.
